
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Contenido</title>
    <link href="https://learn.ifp.es/favicon.ico" rel="icon" type="image/x-icon">
    <link rel="stylesheet" href="style.css" />
</head>
<body>
    <nav>
        <a href="index.html">Uni 1</a>
        <a href="unidad2.html">Uni 2</a>
        <a href="unidad3.html">Uni 3</a>
        <a href="unidad4.html">Uni 4</a>
    </nav>
    <main>
        <h3>3 - Despliegue de Aplicaciones</h3>
        <h3>¿Qué se entiende por despliegue de aplicaciones?</h3>
        <p>El despliegue de aplicaciones corresponde con aquellas actividades que hacen que las aplicaciones informáticas estén disponibles para su uso. <strong>No se trata de cómo desarrollar las aplicaciones, sino de las tareas necesarias para que éstas puedan ser consumidas por los usuarios</strong> en con unas determinadas condiciones como disponibilidad y escalabilidad del servicio, balanceo de carga, seguridad, etc.</p>
    
        <h3>Los inicios, Bare Metal</h3>
        <p>Tradicionalmente el diseño de las aplicaciones se basaba en una estructura monolítica, es decir, compuesta por multitud de procesos alojados en una misma infraestructura física (“hierro”), compartiendo tanto el sistema operativo como determinados ficheros binarios y librerías (lo que se denomina <strong>“dependencias”</strong>).</p>
        <p>En este escenario, cuando se quería realizar una modificación de alguna de las aplicaciones (un cambio de un proceso, una actualización del sistema operativo, un cambio de librería, etc.) había que asegurar que estas modificaciones no afectasen al resto de las aplicaciones y procesos. En cierta medida esto no era un problema cuando se trataba de implementar unas cuantas aplicaciones relativamente sencillas, pero con los años éstas se han ido haciendo cada vez más complejas con multitud de procesos interdependientes, lo que ha llevado a que el mantenimiento del sistema sea cada vez más complejo.</p>


        <h3>1ª Evolución, la Virtualización</h3>
        <p>Con la evolución tecnológica, surge la <strong>virtualización</strong> (2005 es cuando el sistema se populariza), que permite crear múltiples máquinas virtuales (VMs) dentro de un único servidor físico. Cada VM puede alojar una parte específica de la aplicación o servicios distintos, replicando así entornos completos sin depender del hardware físico.</p>

        <p><strong>REQUISITOS:</strong> Para que esta arquitectura sea posible se necesita un componente por encima del sistema operativo anfitrión llamado <em>hypervisor</em> (VirtualBox, VMware, etc.), que exponga los recursos hardware (CPU, memoria, etc.) utilizados por los sistemas operativos <em>huésped</em> de cada una de las máquinas virtuales.</p>

        <h3>Ventajas de la Virtualización</h3>
        <ul>
            <li><strong>Aislamiento y seguridad:</strong> Cada VM funciona de forma independiente, lo que reduce el impacto de fallos en otros entornos.</li>
            <li><strong>Escalabilidad:</strong> Se pueden replicar y escalar entornos fácilmente según la demanda.</li>
            <li><strong>Flexibilidad y portabilidad:</strong> Las aplicaciones se pueden mover entre servidores con poca o ninguna reconfiguración.</li>
            <li><strong>Optimización de recursos:</strong> Se aprovecha mejor el hardware, reduciendo costes de infraestructura.</li>
            <li><strong>Automatización:</strong> La virtualización facilita tareas como el despliegue continuo, pruebas automatizadas y actualizaciones sin afectar al sistema principal.</li>
        </ul>

        <h3>Desventajas de la Virtualización</h3>
        <ul>
            <li><strong>Sobrecarga de recursos:</strong> Cada VM consume memoria y CPU, lo que puede llevar a un uso intensivo del sistema físico.</li>
            <li><strong>Complejidad en la gestión:</strong> Administrar múltiples entornos virtuales requiere herramientas y conocimientos especializados.</li>
            <li><strong>Dependencia de software de virtualización:</strong> Problemas en el hypervisor o en la plataforma de virtualización pueden afectar a todas las VMs.</li>
            <li><strong>Seguridad:</strong> Aunque hay aislamiento, una mala configuración puede abrir puertas a ataques entre entornos virtualizados.</li>
        </ul>


        <h3>2ª Evolución, los Microservicios</h3>
        <p>Los microservicios son una forma de arquitectura de software en la que una aplicación se construye como un conjunto de servicios pequeños e independientes. Cada microservicio se enfoca en una única funcionalidad del sistema, se desarrolla, despliega y escala de manera independiente, y se comunica con otros servicios mediante APIs (generalmente REST o mensajes).</p>

        <p>Aunque los conceptos fundamentales existen desde los años 90, <strong>el término “microservicios” empezó a ganar notoriedad entre 2011 y 2012</strong>, cuando empresas como <em>Netflix, Amazon y Spotify</em> empezaron a compartir sus estrategias de escalabilidad a gran escala.</p>

        <p>Un microservicio es un pequeño desarrollo autónomo y escalable que se puede desplegar de manera independiente, de forma que las aplicaciones se puedan desarrollar como un conjunto de microservicios interrelacionados.</p>

        <p>Si un sistema se compone de unas pocas aplicaciones, una solución es alojar cada aplicación en una máquina virtual, pero en un sistema compuesto por <strong>una gran cantidad de microservicios es inviable alojar cada microservicio en una VM</strong> si queremos mantener un bajo coste del hardware y de los recursos necesarios, además del aumento de mano de obra técnica que se necesita para configurar y mantener esta cantidad de máquinas virtuales.</p>


        <h3>3ª Evolución, la contenerización</h3>
        <p>La contenerización es el empaquetado de código de software con solo las bibliotecas del sistema operativo (SO) y las dependencias necesarias para ejecutar el código con el fin de crear un único ejecutable ligero, denominado contenedor, que se ejecuta de forma coherente en cualquier infraestructura.</p>

        <p>Los contenedores, más portátiles y eficientes en recursos que las máquinas virtuales (VM), se han convertido en las unidades de computación de facto de las modernas aplicaciones nativas en la nube.</p>

        <p>La contenerización permite a los desarrolladores crear e implementar aplicaciones de forma más rápida y segura.</p>

        <p>Con los métodos tradicionales, los desarrolladores escriben código en un entorno informático específico que, cuando se traslada a una nueva ubicación, suele dar lugar a fallos y errores. Por ejemplo, esto puede ocurrir cuando un desarrollador transfiere código desde su ordenador de sobremesa a una máquina virtual o un sistema operativo Linux a uno Windows.</p>

        <p>La contenerización elimina este problema al agrupar el código de la aplicación con los archivos de configuración, las bibliotecas y las dependencias relacionadas necesarias para que se ejecute. <strong>Este único paquete de software o “contenedor” se abstrae del sistema operativo anfitrión. Por lo tanto, es independiente y se vuelve portátil, capaz de ejecutarse en cualquier plataforma o nube, sin problemas.</strong></p>


        <h3>Los Contenedores. Las Imágenes</h3>
        <p>En un contenedor podemos instalar, por ejemplo, un servidor Apache, una máquina con una base de datos MySQL, una máquina con un sistema operativo Ubuntu, etc.</p>

        <p>Una imagen es una plantilla de <strong>solo lectura que empaqueta todo el software necesario para poder ejecutarse en un contenedor</strong>, tanto el propio código de la aplicación como todas las dependencias necesarias (librerías, etc.).</p>

        <p>Podemos considerar que es el software que va a correr en el propio contenedor, de hecho, se dice que un contenedor es una instancia de la imagen con los datos que se ha creado.</p>

        <p>Existen imágenes de un servidor Apache, un servidor Nginx, una máquina Ubuntu, una máquina con una base de datos Redis, etc. Para crear una imagen que incluya una determinada aplicación se dispone básicamente de tres opciones:</p>

        <ul>
            <li>Con Docker, a partir de un fichero de texto plano denominado Dockerfile.</li>
            <li>A partir de una imagen base (“Image Builder”) usando herramientas del tipo S2I (“Source to Image”), como se hace en OpenShift (Kubernetes).</li>
            <li>Descargándolas de un registro de imágenes o repositorio. (Docker Hub).</li>
        </ul>

        <div style="border:1px solid #ccc; padding: 1rem; margin-top: 1rem;">
            <h3>¿Qué es un Pod?</h3>
            <p>Un Pod es la unidad mínima de ejecución en <strong>Kubernetes</strong>. Se puede pensar como un “contenedor lógico” que <strong>encapsula uno o más contenedores</strong> que deben ejecutarse juntos.</p>
        </div>


        <h2>El Cloud Computing</h2>
        <p><strong>Cloud Computing</strong> (Computación en la Nube) es el modelo que permite acceder a recursos informáticos —como servidores, almacenamiento, bases de datos, redes y software— a través de Internet, bajo demanda y mediante pago por uso. En el contexto del despliegue de aplicaciones web, la infraestructura de la nube está formada por un conjunto de <strong>sistemas hardware físicos distribuidos geográficamente</strong>, conocidos como Centros de Datos (Data Centers).</p>

        <p>En estos centros se encuentran elementos esenciales como <strong>servidores, routers, switches, firewalls, balanceadores de carga y sistemas de almacenamiento</strong>, que conforman la base física sobre la que se ejecutan los servicios cloud.</p>

        <p>Cuando una empresa o desarrollador desea <strong>desplegar su aplicación en la nube</strong>, lo hace habitualmente en forma de contenedores. Estos contenedores se ejecutan sobre un conjunto de nodos, agrupados en lo que se conoce como un <strong>clúster</strong>.</p>

        <h2>Modelos de Servicio en la Nube</h2>
        <ol>
            <li><strong>Software como Servicio (SaaS):</strong> En este modelo de servicio, el proveedor de la nube pone sus aplicaciones e infraestructura a disposición de los consumidores. El proveedor se encarga de mantener y actualizar el hardware, sistemas operativos, aplicaciones, etc., mientras que los clientes simplemente usan las aplicaciones del proveedor. <em>(Gmail, Microsoft Office 365, WordPress)</em></li>

            <li><strong>Plataforma como Servicio (PaaS):</strong> En este caso, el proveedor pone tanto la infraestructura como las herramientas necesarias para que los usuarios únicamente se enfoquen en implementar y desarrollar sus aplicaciones (sistema operativo, gestor de bases de datos, etc.). Este es el entorno preferido por los desarrolladores pues se desentienden completamente de los servidores, del sistema operativo, de sus actualizaciones, las dependencias, etc. Ejemplo de servicios PaaS son los que ofrece Google con Google Cloud, Red Hat con OpenShift, etc.</li>

            <li><strong>Infraestructura como Servicio (IaaS):</strong> En esta modalidad de servicio, el proveedor de la nube suministra la infraestructura, el “Bare metal”, que pone a disposición de los clientes a cambio de una cuota o alquiler, es decir, el proveedor ofrece capacidad de proceso (CPU), espacio de almacenamiento (memoria), máquinas virtuales, cortafuegos, balanceadores, etc.</li>
        </ol>


        <h2>Conceptos Clave</h2>
        <h2>Verificación de parámetros de red: puertos, servicios activos</h2>

        <h4>Puertos comunes en aplicaciones web:</h4>
        <ul>
            <li><strong>80:</strong> HTTP (sin cifrado)</li>
            <li><strong>443:</strong> HTTPS (con SSL/TLS)</li>
            <li><strong>21:</strong> FTP (transferencia de archivos)</li>
            <li><strong>22:</strong> SFTP/SSH (acceso seguro y transferencia cifrada)</li>
            <li><strong>3306:</strong> MySQL</li>
            <li><strong>5432:</strong> PostgreSQL</li>
            <li><strong>8080:</strong> Tomcat u otros servicios HTTP alternativos</li>
        </ul>

        <h4>Ver qué puertos están escuchando:</h4>
        <p><code>sudo netstat</code></p>

        <h4>Localización de IP pública de servidores:</h4>
        <p>Verificación servidor web</p>

        <h4>DNS:</h4>
        <p><code>/etc/resolv.conf</code> (Fichero de configuración)</p>

</main>
</body>
</html>
